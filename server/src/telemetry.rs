use chrono::{DateTime, Utc};
use serde::{de::Error as DeError, Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::UdpSocket;
use tokio::sync::{broadcast, RwLock};
use tracing::Instrument;

/// 3D position in meters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

/// velocity in meters/second
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Velocity {
    pub vx: f64,
    pub vy: f64,
    pub vz: f64,
}

/// state of a single UAV sent to WebSocket clients
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UavState {
    pub id: u64,
    pub position: Position,
    pub velocity: Velocity,
    pub timestamp: DateTime<Utc>,
}

/// Swarm Behavior settings sent from the UI over WebSocket
#[derive(Debug, Clone, Deserialize)]
pub struct SwarmSettings {
    pub cohesion: f64,
    pub separation: f64,
    pub alignment: f64,
    #[serde(rename = "maxSpeed")]
    pub max_speed: f64,
    #[serde(rename = "targetAltitude")]
    pub target_altitude: f64,
}

/// Obstacles as generated by the simulator and visualized by the UI
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum ObstacleType {
    #[serde(rename_all = "camelCase")]
    Cylinder {
        x: f64,
        y: f64,
        z: f64,
        radius: f64,
        height: f64,
    },
    #[serde(rename_all = "camelCase")]
    Box {
        x: f64,
        y: f64,
        z: f64,
        width: f64,
        depth: f64,
        height: f64,
    },
    #[serde(rename_all = "camelCase")]
    Sphere {
        x: f64,
        y: f64,
        z: f64,
        radius: f64,
    },
}

/// Environment message sent from the simulator over UDP:
/// {
///   "type": "environment",
///   "obstacles": [ ... ObstacleType ... ]
/// }
#[derive(Debug, Deserialize)]
struct EnvironmentMessage {
    #[serde(rename = "type")]
    msg_type: String,
    obstacles: Vec<ObstacleType>,
}

/// state of UAV swarm
#[derive(Clone)]
pub struct SwarmState {
    inner: Arc<RwLock<HashMap<u64, UavState>>>,
    settings: Arc<RwLock<SwarmSettings>>,
    last_command: Arc<RwLock<Option<serde_json::Value>>>,
}

impl SwarmState {
    pub fn new() -> Self {
        SwarmState {
            inner: Arc::new(RwLock::new(HashMap::new())),
            settings: Arc::new(RwLock::new(SwarmSettings {
                cohesion: 1.0,
                separation: 1.0,
                alignment: 1.0,
                max_speed: 10.0,
                target_altitude: 10.0,
            })),
            last_command: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn upsert_uav(&self, state: UavState) {
        let mut map = self.inner.write().await;
        map.insert(state.id, state);
    }

    pub async fn get_uav(&self, id: u64) -> Option<UavState> {
        let map = self.inner.read().await;
        map.get(&id).cloned()
    }

    pub async fn list_uavs(&self) -> Vec<UavState> {
        let map = self.inner.read().await;
        map.values().cloned().collect()
    }

    /// command from UI to control swarm behavior
    pub async fn apply_command(&self, cmd: serde_json::Value) {
        {
            let mut last = self.last_command.write().await;
            *last = Some(cmd.clone());
        }

        tracing::info!(swarm_command_from_ui = %cmd);
    }

    /// apply swarm behavior settings from UI
    pub async fn apply_settings(&self, settings: SwarmSettings) {
        {
            let mut current = self.settings.write().await;
            *current = settings.clone();
        }

        tracing::info!(
            cohesion = settings.cohesion,
            separation = settings.separation,
            alignment = settings.alignment,
            max_speed = settings.max_speed,
            target_altitude = settings.target_altitude,
            updated_swarm_settings_from_ui = true,
        );
    }

    /// get the current swarm settings snapshot
    pub async fn current_settings(&self) -> SwarmSettings {
        let s = self.settings.read().await;
        s.clone()
    }

    /// get the last command received from the UI, if any
    pub async fn last_command(&self) -> Option<serde_json::Value> {
        let c = self.last_command.read().await;
        c.clone()
    }
}

/// shared handles used by both UDP listener and WebSocket server
#[derive(Clone)]
pub struct TelemetryShared {
    pub swarm: SwarmState,
    pub tx: broadcast::Sender<UavState>,
    /// Obstacles as last reported by the simulator
    pub obstacles: Arc<RwLock<Vec<ObstacleType>>>,
}

/// start UDP listener that receives telemetry frames and environment updates,
/// updates swarm state, and broadcasts telemetry updates to WebSocket clients
pub async fn run_udp_listener(bind_addr: SocketAddr, shared: TelemetryShared) {
    let socket = match UdpSocket::bind(bind_addr).await {
        Ok(s) => s,
        Err(err) => {
            tracing::error!("Failed to bind UDP socket at {}: {}", bind_addr, err);
            return;
        }
    };

    tracing::info!("UDP telemetry listener bound at {}", bind_addr);

    loop {
        let mut buf = vec![0u8; 2048];
        let span = tracing::info_span!("udp_recv");
        let shared = shared.clone();
        let socket = &socket;
        let addr = bind_addr;

        let fut = async move {
            let (len, src) = match socket.recv_from(&mut buf).await {
                Ok(res) => res,
                Err(err) => {
                    tracing::warn!("Error receiving UDP packet: {}", err);
                    return;
                }
            };

            let data = &buf[..len];
            tracing::info!("udp_recv: received {} bytes from {}", len, src);

            // First, try to decode an environment / obstacles update from the simulator
            if let Ok(env) = serde_json::from_slice::<EnvironmentMessage>(data) {
                if env.msg_type == "environment" {
                    {
                        let mut guard = shared.obstacles.write().await;
                        *guard = env.obstacles.clone();
                    }
                    tracing::info!(
                        "udp_recv: updated environment from sim with {} obstacles",
                        env.obstacles.len()
                    );
                    // this packet was an environment update; no telemetry frame inside
                    return;
                }
            }

            // Otherwise, treat it as a telemetry frame for a single UAV
            match decode_frame(data) {
                Ok(uav) => {
                    let id = uav.id;
                    tracing::info!("udp_recv: decoded telemetry frame for UAV {}", id);
                    shared.swarm.upsert_uav(uav.clone()).await;

                    // broadcast the update; ignore if there are no listeners.
                    if let Err(e) = shared.tx.send(uav) {
                        tracing::debug!(
                            "No WebSocket subscribers for update {}: {}",
                            id,
                            e
                        );
                    }
                }
                Err(err) => {
                    tracing::warn!(
                        "Failed to decode telemetry frame from {}: {}",
                        src,
                        err
                    );
                }
            }
        };

        fut.instrument(span).await;
        // loop continues
        tracing::trace!("Waiting for next UDP telemetry packet on {}", addr);
    }
}

/// decode a UDP datagram into a `UavState`.
///
/// This expects a single JSON object with fields:
/// { "id": number, "position": {x,y,z}, "velocity": {vx,vy,vz}, "timestamp": string }
fn decode_frame(data: &[u8]) -> Result<UavState, serde_json::Error> {
    // Parse to a generic JSON value first so we can be lenient about shape
    let v: Value = serde_json::from_slice(data)?;

    let obj = v
        .as_object()
        .ok_or_else(|| DeError::custom("expected JSON object for telemetry frame"))?;

    let id = obj
        .get("id")
        .and_then(|v| v.as_u64())
        .ok_or_else(|| DeError::custom("missing or invalid 'id' field"))?;

    let pos_obj = obj
        .get("position")
        .and_then(|v| v.as_object())
        .ok_or_else(|| DeError::custom("missing or invalid 'position' field"))?;

    let vel_obj = obj
        .get("velocity")
        .and_then(|v| v.as_object())
        .ok_or_else(|| DeError::custom("missing or invalid 'velocity' field"))?;

    let position = Position {
        x: pos_obj.get("x").and_then(|v| v.as_f64()).unwrap_or(0.0),
        y: pos_obj.get("y").and_then(|v| v.as_f64()).unwrap_or(0.0),
        z: pos_obj.get("z").and_then(|v| v.as_f64()).unwrap_or(0.0),
    };

    let velocity = Velocity {
        vx: vel_obj.get("vx").and_then(|v| v.as_f64()).unwrap_or(0.0),
        vy: vel_obj.get("vy").and_then(|v| v.as_f64()).unwrap_or(0.0),
        vz: vel_obj.get("vz").and_then(|v| v.as_f64()).unwrap_or(0.0),
    };

    Ok(UavState {
        id,
        position,
        velocity,
        // Use server receive time as the authoritative timestamp
        timestamp: Utc::now(),
    })
}
